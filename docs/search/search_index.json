{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Orgmode \u00b6 A Clojure library designed to parse mode files into clojure data structures. Status \u00b6 Usable, but not perfect, parse the test file to see some of the issues. Installation \u00b6 Using deps , add the coordinate to your deps.edn : { :deps { orgmode { :git/url \"https://github.com/bnbeckwith/orgmode\" :sha \"5b83296a645af8011ed282b86de1d5995a9914f8\" } }} If you are using lein , just add it as a dependency: [ bnbeckwith.com/orgmode \"0.7.5\" ] Usage \u00b6 In your favorite terminal, launch a repl with clojure -Adev ( ns main ( :require [ orgmode.core :as org ])) ( org/parse-str \"* Headline\" ) ; {:content [{:type :headline, :text \"Headline\", :todo nil, :level 1, :content [], :tags nil}], :level 0} ( org/parse-str \"[[http://clojure.org][Clojure]]\" ) ; {:content [{:inline true, :type :link, :uri \"http://clojure.org\", :content [\"Clojure\"]}], :level 0} ( org/parse \"File.org\" ) ; File structure License \u00b6 Copyright \u00a9 2012-2020 Benjamin Beckwith Distributed under the Eclipse Public License, the same as Clojure. Contributors \u00b6 Benjamin Beckwith David Pham","title":"Home"},{"location":"#orgmode","text":"A Clojure library designed to parse mode files into clojure data structures.","title":"Orgmode"},{"location":"#status","text":"Usable, but not perfect, parse the test file to see some of the issues.","title":"Status"},{"location":"#installation","text":"Using deps , add the coordinate to your deps.edn : { :deps { orgmode { :git/url \"https://github.com/bnbeckwith/orgmode\" :sha \"5b83296a645af8011ed282b86de1d5995a9914f8\" } }} If you are using lein , just add it as a dependency: [ bnbeckwith.com/orgmode \"0.7.5\" ]","title":"Installation"},{"location":"#usage","text":"In your favorite terminal, launch a repl with clojure -Adev ( ns main ( :require [ orgmode.core :as org ])) ( org/parse-str \"* Headline\" ) ; {:content [{:type :headline, :text \"Headline\", :todo nil, :level 1, :content [], :tags nil}], :level 0} ( org/parse-str \"[[http://clojure.org][Clojure]]\" ) ; {:content [{:inline true, :type :link, :uri \"http://clojure.org\", :content [\"Clojure\"]}], :level 0} ( org/parse \"File.org\" ) ; File structure","title":"Usage"},{"location":"#license","text":"Copyright \u00a9 2012-2020 Benjamin Beckwith Distributed under the Eclipse Public License, the same as Clojure.","title":"License"},{"location":"#contributors","text":"Benjamin Beckwith David Pham","title":"Contributors"},{"location":"orgmode/block/","text":"Block Element Formatting \u00b6 These functions parse an Org-mode file and generate the necessary heirarchy of list and block elements. orgmode.block \u00b6 (ns) ( ns orgmode.block ( :require [ clojure.string :as s ] [ clojure.zip :as zip ]) ( :use [ orgmode.inline ])) Regular Expressions for Block Elements \u00b6 The following set of regular expressions match start and end elements of blocks or block elements themselves. Note that some items are line items, but I considered them blocks of the smallest size. attrib-re \u00b6 Attribute Regular Expression that captures the attribute name and any values (as a single string) (def) ( def attrib-re # \"^#\\+(\\w+):\\s*(.*)\" ) prop-open-re \u00b6 Regex for the beginning of a properties block (def) ( def prop-open-re # \"\\s*:PROPERTIES:\\s*\" ) property-line-re \u00b6 Regex that captures property keys and values from within a properties drawer (def) ( def property-line-re # \"\\s*:(\\w+):\\s*(.*)\" ) block-open-re \u00b6 Regex that matches the start of a begin_* block. It captures the type of block along with any parameters (as a single string) (def) ( def block-open-re # \"^#\\+(?i)BEGIN_(\\w+)(?:\\s+(.*))?\" ) block-close-re \u00b6 Regex that matches the end of a begin block (def) ( def block-close-re # \"^#\\+(?i)END_\" ) comment-re \u00b6 Regex that matches an inline comment (def) ( def comment-re # \"^\\s*#\\s+(.*)\" ) headline-re \u00b6 Regex that matches headlines and todo items. This regex does a bunch of work and captures the leading stars, TODO or DONE tags, headline text, and tags. (def) ( def headline-re ;; TODO -- capture priority here? # \"^(\\*+)\\s+(?:(TODO|DONE)\\s+)?(.*?)(?:\\s+:(.*):)?\" ) plain-list-re \u00b6 Regex that matches a plain list. This regex captues leading spaces, the bullets or indices, and item text (def) ( def plain-list-re # \"^(\\s*)([-+*]|[0-9]+[.)])\\s(.*)\" ) footnote-def-re \u00b6 Regex denoting a footnote definition. Captures identifier and definition (def) ( def footnote-def-re # \"^\\s*\\[(\\d+|fn:(.*))\\] (.*)\" ) table-re \u00b6 Regex to match table lines. Captures fields as one string (def) ( def table-re # \"^\\s*\\|(.*)\" ) table-formula-re \u00b6 Regex to match table formula. Caputes the list of formulas as one string (def) ( def table-formula-re # \"\\s*#\\+TBLFM:\\s*(.*)\" ) Processing Functions \u00b6 handle-last-line \u00b6 Macro to help break out of further processing if line is nil. Returns root of z (defmacro) ( defmacro handle-last-line [[ line z ] & body ] ` ( if-not ( nil? ~ line ) ( do ~@ body ) ( zip/root ~ z ))) next-line \u00b6 (declare) ( declare next-line ) parse-attrib \u00b6 At current location z, add attribute with name and values ( parse-attrib [ & rest ] z [ _ name values ]) (defn) ( defn parse-attrib [[ & rest ] z [ _ name values ]] ( fn [] ( next-line rest ( zip/edit z # ( assoc-in %1 [ :attribs ( keyword ( .toLowerCase name ))] values ))))) parse-comment \u00b6 At current location z, add comment with parsed text ( parse-comment [ & rest ] z [ _ comment ]) (defn) ( defn parse-comment [[ & rest ] z [ _ comment ]] ( fn [] ( next-line rest ( zip/append-child z { :type :comment :content ( orgmode.inline/parse-inline-elements comment )})))) parse-footnote \u00b6 Add current location z, add a footnote definition ( parse-footnote [ & rest ] z [ _ nid fid text ]) (defn) ( defn parse-footnote [[ & rest ] z [ _ nid fid text ]] ( fn [] ( next-line rest ( zip/append-child z { :type :footnote :id ( or fid nid ) :content ( orgmode.inline/parse-inline-elements text )})))) move-level \u00b6 Given level, move up z until the location is an appropiate place to add elements at level. ( move-level z level ) (defn) ( defn move-level [ z level ] ( let [ cnode ( zip/node z ) clevel ( get cnode :level level )] ( if ( > level clevel ) z ( recur ( zip/up z ) level )))) parse-headline \u00b6 Insert a headline at z and make it the new location. ( parse-headline [ & rest ] z [ _ stars todo headline tag ]) (defn) ( defn parse-headline [[ & rest ] z [ _ stars todo headline tag ]] ( let [ lvl ( count stars ) zz ( move-level z lvl )] # ( next-line rest ( -> zz ( zip/append-child { :type :headline :text headline :todo todo :level lvl :content [] :tags ( when tag ( into # {} ( s/split tag # \":\" )))}) zip/down zip/rightmost )))) parse-property \u00b6 Parse a property block, adding property keys and values until an end tag is encountered ( parse-property [ line & rest ] z ) ( parse-property [ & rest ] z _ ) (defn) ( defn parse-property ([[ line & rest ] z ] { :pre [( = :headline ( -> z zip/node ( :type )))]} ( handle-last-line [ line z ] ( if-let [[ _ prop value ] ( re-matches property-line-re line )] ( if ( = prop \"END\" ) # ( next-line rest z ) ( fn [] ( parse-property rest ( zip/edit z # ( assoc-in % [ :properties ( keyword ( .toLowerCase prop ))] value ))))) ( throw ( Exception. ( str \"No :END: for propery block (looking at \\\"\" line \"\\\"\" )))))) ([[ & rest ] z _ ] # ( parse-property rest z ))) parse-block \u00b6 Parse a block structure, keeping attribues and adding lines until an end tag is encountered ( parse-block [ line & rest ] z ) ( parse-block [ & rest ] z [ _ type attribs ]) (defn) ( defn parse-block ([[ line & rest ] z ] ( handle-last-line [ line z ] ( let [ type ( name ( :block ( zip/node z ))) end-re ( re-pattern ( str block-close-re type # \"\\s*\" ))] ( if ( re-matches end-re line ) # ( next-line rest ( zip/up z )) # ( parse-block rest ( zip/append-child z line )))))) ([[ & rest ] z [ _ type attribs ]] # ( parse-block rest ( -> z ( zip/append-child { :type :block :block ( keyword ( .toLowerCase type )) :content [] :attribs ( when attribs ( s/split attribs # \"\\s+\" ))}) zip/down zip/rightmost )))) enclosing-plain-list \u00b6 Move z up to appropiate level enclosing the current list ( enclosing-plain-list z level ) (defn) ( defn enclosing-plain-list [ z level ] ( if ( or ( not= :list ( :type ( zip/node z ))) ( = level ( :listlevel ( zip/node z )))) z ( recur ( zip/up z ) level ))) parse-plain-list \u00b6 Parse a plain list, keeping track of any nested heirarchy. ( parse-plain-list [ line & rest :as lines ] z [ _ lvl idx text :as params ]) ( parse-plain-list [ line & rest :as lines ] z ) (defn) ( defn parse-plain-list ([[ line & rest :as lines ] z [ _ lvl idx text :as params ]] ( let [ level ( + ( count lvl ) ( count idx )) listtype ( if ( re-find # \"^[0-9]+\" idx ) :ol :ul )] ( if ( = :list ( :type ( zip/node z ))) ( if ( = level ( :listlevel ( zip/node z ))) ( parse-plain-list lines ( zip/append-child z { :type :listitem :content ( orgmode.inline/parse-inline-elements text )})) ( if ( > level ( :listlevel ( zip/node z ))) ( parse-plain-list lines ( -> z ( zip/down ) ( zip/append-child { :type :list :listlevel level :listtype listtype :content [{ :type :listitem :content ( orgmode.inline/parse-inline-elements text )}]}) ( zip/down ) ( zip/rightmost ))) ( parse-plain-list lines ( enclosing-plain-list z level ) params ))) ( parse-plain-list lines ( -> z ( zip/append-child { :type :list :listlevel level :listtype listtype :content [{ :type :listitem :content ( orgmode.inline/parse-inline-elements text )}]}) ( zip/down ) ( zip/rightmost )))))) ([[ line & rest :as lines ] z ] ( handle-last-line [ line z ] ( let [ indent-re ( re-pattern ( format \"(\\\\s{%d,})(.*)\" ( :listlevel ( zip/node z ))))] ( condp re-matches line plain-list-re :>> ( partial parse-plain-list rest z ) indent-re :>> # ( parse-plain-list rest ( -> z ( zip/down ) ( zip/append-child %1 ) ( zip/up ))) ( next-line lines ( zip/up z ))))))) append-table-line \u00b6 Append table row s to location z. Splits s into fields ( append-table-line z s ) (defn) ( defn append-table-line [ z s ] ( let [ row ( if ( re-matches # \"[-+]+\\|?\" s ) :tline ( map s/trim ( s/split s # \"\\|\" )))] ( zip/edit z # ( update-in % [ :rows ] conj row )))) add-table-formula \u00b6 Add table formula at z, splitting s into separate formulas. ( add-table-formula z s ) (defn) ( defn add-table-formula [ z s ] ( zip/edit z # ( update-in % [ :formulas ] ( s/split s # \"::\" )))) parse-table \u00b6 Parse a table to add at location z ( parse-table [ & lines ] z [ _ tblline ]) (defn) ( defn parse-table [[ & lines ] z [ _ tblline ]] ( let [ fields ( map s/trim ( s/split tblline # \"\\|\" )) z ' ( -> z ( zip/append-child { :type :table :content [] :rows [ fields ]}) ( zip/down ) ( zip/rightmost ))] ( loop [ ls lines z '' z ' ] ( handle-last-line [( first ls ) z '' ] ( if-let [[ _ l ] ( re-matches table-re ( first ls ))] ( recur ( rest ls ) ( append-table-line z '' l )) ( if-let [[ _ f ] ( re-matches table-formula-re ( first ls ))] ( next-line ( rest ls ) ( add-table-formula z '' f )) ( next-line ls ( zip/up z '' )))))))) add-line-element \u00b6 Parse line for inline elements and add sequence at z. ( add-line-element lines z line ) (defn) ( defn add-line-element [ lines z line ] # ( next-line lines ( if ( re-matches # \"\\s*\" line ) ( -> z ( zip/append-child { :type :p :content []}) ( zip/down ) ( zip/rightmost )) ( reduce zip/append-child z ( orgmode.inline/parse-inline-elements line ))))) next-line \u00b6 ( next-line [ line & rest ] z ) (defn) ( defn next-line [[ line & rest ] z ] \"Process each line with the list of block element parsers. Return the root of the created zipper structure\" ( handle-last-line [ line z ] ( condp re-matches line block-open-re :>> ( partial parse-block rest z ) attrib-re :>> ( partial parse-attrib rest z ) headline-re :>> ( partial parse-headline rest z ) prop-open-re :>> ( partial parse-property rest z ) plain-list-re :>> ( partial parse-plain-list rest z ) table-re :>> ( partial parse-table rest z ) footnote-def-re :>> ( partial parse-footnote rest z ) comment-re :>> ( partial parse-comment rest z ) ( add-line-element rest z line )))) parse-lines \u00b6 Parse coll as org-mode formatting ( parse-lines coll ) (defn) ( defn parse-lines [ coll ] ( let [ root ( clojure.zip/xml-zip { :level 0 })] ( trampoline next-line coll root )))","title":"Block"},{"location":"orgmode/block/#block-element-formatting","text":"These functions parse an Org-mode file and generate the necessary heirarchy of list and block elements.","title":"Block Element Formatting"},{"location":"orgmode/block/#orgmodeblock","text":"(ns) ( ns orgmode.block ( :require [ clojure.string :as s ] [ clojure.zip :as zip ]) ( :use [ orgmode.inline ]))","title":"orgmode.block"},{"location":"orgmode/block/#regular-expressions-for-block-elements","text":"The following set of regular expressions match start and end elements of blocks or block elements themselves. Note that some items are line items, but I considered them blocks of the smallest size.","title":"Regular Expressions for Block Elements"},{"location":"orgmode/block/#attrib-re","text":"Attribute Regular Expression that captures the attribute name and any values (as a single string) (def) ( def attrib-re # \"^#\\+(\\w+):\\s*(.*)\" )","title":"attrib-re"},{"location":"orgmode/block/#prop-open-re","text":"Regex for the beginning of a properties block (def) ( def prop-open-re # \"\\s*:PROPERTIES:\\s*\" )","title":"prop-open-re"},{"location":"orgmode/block/#property-line-re","text":"Regex that captures property keys and values from within a properties drawer (def) ( def property-line-re # \"\\s*:(\\w+):\\s*(.*)\" )","title":"property-line-re"},{"location":"orgmode/block/#block-open-re","text":"Regex that matches the start of a begin_* block. It captures the type of block along with any parameters (as a single string) (def) ( def block-open-re # \"^#\\+(?i)BEGIN_(\\w+)(?:\\s+(.*))?\" )","title":"block-open-re"},{"location":"orgmode/block/#block-close-re","text":"Regex that matches the end of a begin block (def) ( def block-close-re # \"^#\\+(?i)END_\" )","title":"block-close-re"},{"location":"orgmode/block/#comment-re","text":"Regex that matches an inline comment (def) ( def comment-re # \"^\\s*#\\s+(.*)\" )","title":"comment-re"},{"location":"orgmode/block/#headline-re","text":"Regex that matches headlines and todo items. This regex does a bunch of work and captures the leading stars, TODO or DONE tags, headline text, and tags. (def) ( def headline-re ;; TODO -- capture priority here? # \"^(\\*+)\\s+(?:(TODO|DONE)\\s+)?(.*?)(?:\\s+:(.*):)?\" )","title":"headline-re"},{"location":"orgmode/block/#plain-list-re","text":"Regex that matches a plain list. This regex captues leading spaces, the bullets or indices, and item text (def) ( def plain-list-re # \"^(\\s*)([-+*]|[0-9]+[.)])\\s(.*)\" )","title":"plain-list-re"},{"location":"orgmode/block/#footnote-def-re","text":"Regex denoting a footnote definition. Captures identifier and definition (def) ( def footnote-def-re # \"^\\s*\\[(\\d+|fn:(.*))\\] (.*)\" )","title":"footnote-def-re"},{"location":"orgmode/block/#table-re","text":"Regex to match table lines. Captures fields as one string (def) ( def table-re # \"^\\s*\\|(.*)\" )","title":"table-re"},{"location":"orgmode/block/#table-formula-re","text":"Regex to match table formula. Caputes the list of formulas as one string (def) ( def table-formula-re # \"\\s*#\\+TBLFM:\\s*(.*)\" )","title":"table-formula-re"},{"location":"orgmode/block/#processing-functions","text":"","title":"Processing Functions"},{"location":"orgmode/block/#handle-last-line","text":"Macro to help break out of further processing if line is nil. Returns root of z (defmacro) ( defmacro handle-last-line [[ line z ] & body ] ` ( if-not ( nil? ~ line ) ( do ~@ body ) ( zip/root ~ z )))","title":"handle-last-line"},{"location":"orgmode/block/#next-line","text":"(declare) ( declare next-line )","title":"next-line"},{"location":"orgmode/block/#parse-attrib","text":"At current location z, add attribute with name and values ( parse-attrib [ & rest ] z [ _ name values ]) (defn) ( defn parse-attrib [[ & rest ] z [ _ name values ]] ( fn [] ( next-line rest ( zip/edit z # ( assoc-in %1 [ :attribs ( keyword ( .toLowerCase name ))] values )))))","title":"parse-attrib"},{"location":"orgmode/block/#parse-comment","text":"At current location z, add comment with parsed text ( parse-comment [ & rest ] z [ _ comment ]) (defn) ( defn parse-comment [[ & rest ] z [ _ comment ]] ( fn [] ( next-line rest ( zip/append-child z { :type :comment :content ( orgmode.inline/parse-inline-elements comment )}))))","title":"parse-comment"},{"location":"orgmode/block/#parse-footnote","text":"Add current location z, add a footnote definition ( parse-footnote [ & rest ] z [ _ nid fid text ]) (defn) ( defn parse-footnote [[ & rest ] z [ _ nid fid text ]] ( fn [] ( next-line rest ( zip/append-child z { :type :footnote :id ( or fid nid ) :content ( orgmode.inline/parse-inline-elements text )}))))","title":"parse-footnote"},{"location":"orgmode/block/#move-level","text":"Given level, move up z until the location is an appropiate place to add elements at level. ( move-level z level ) (defn) ( defn move-level [ z level ] ( let [ cnode ( zip/node z ) clevel ( get cnode :level level )] ( if ( > level clevel ) z ( recur ( zip/up z ) level ))))","title":"move-level"},{"location":"orgmode/block/#parse-headline","text":"Insert a headline at z and make it the new location. ( parse-headline [ & rest ] z [ _ stars todo headline tag ]) (defn) ( defn parse-headline [[ & rest ] z [ _ stars todo headline tag ]] ( let [ lvl ( count stars ) zz ( move-level z lvl )] # ( next-line rest ( -> zz ( zip/append-child { :type :headline :text headline :todo todo :level lvl :content [] :tags ( when tag ( into # {} ( s/split tag # \":\" )))}) zip/down zip/rightmost ))))","title":"parse-headline"},{"location":"orgmode/block/#parse-property","text":"Parse a property block, adding property keys and values until an end tag is encountered ( parse-property [ line & rest ] z ) ( parse-property [ & rest ] z _ ) (defn) ( defn parse-property ([[ line & rest ] z ] { :pre [( = :headline ( -> z zip/node ( :type )))]} ( handle-last-line [ line z ] ( if-let [[ _ prop value ] ( re-matches property-line-re line )] ( if ( = prop \"END\" ) # ( next-line rest z ) ( fn [] ( parse-property rest ( zip/edit z # ( assoc-in % [ :properties ( keyword ( .toLowerCase prop ))] value ))))) ( throw ( Exception. ( str \"No :END: for propery block (looking at \\\"\" line \"\\\"\" )))))) ([[ & rest ] z _ ] # ( parse-property rest z )))","title":"parse-property"},{"location":"orgmode/block/#parse-block","text":"Parse a block structure, keeping attribues and adding lines until an end tag is encountered ( parse-block [ line & rest ] z ) ( parse-block [ & rest ] z [ _ type attribs ]) (defn) ( defn parse-block ([[ line & rest ] z ] ( handle-last-line [ line z ] ( let [ type ( name ( :block ( zip/node z ))) end-re ( re-pattern ( str block-close-re type # \"\\s*\" ))] ( if ( re-matches end-re line ) # ( next-line rest ( zip/up z )) # ( parse-block rest ( zip/append-child z line )))))) ([[ & rest ] z [ _ type attribs ]] # ( parse-block rest ( -> z ( zip/append-child { :type :block :block ( keyword ( .toLowerCase type )) :content [] :attribs ( when attribs ( s/split attribs # \"\\s+\" ))}) zip/down zip/rightmost ))))","title":"parse-block"},{"location":"orgmode/block/#enclosing-plain-list","text":"Move z up to appropiate level enclosing the current list ( enclosing-plain-list z level ) (defn) ( defn enclosing-plain-list [ z level ] ( if ( or ( not= :list ( :type ( zip/node z ))) ( = level ( :listlevel ( zip/node z )))) z ( recur ( zip/up z ) level )))","title":"enclosing-plain-list"},{"location":"orgmode/block/#parse-plain-list","text":"Parse a plain list, keeping track of any nested heirarchy. ( parse-plain-list [ line & rest :as lines ] z [ _ lvl idx text :as params ]) ( parse-plain-list [ line & rest :as lines ] z ) (defn) ( defn parse-plain-list ([[ line & rest :as lines ] z [ _ lvl idx text :as params ]] ( let [ level ( + ( count lvl ) ( count idx )) listtype ( if ( re-find # \"^[0-9]+\" idx ) :ol :ul )] ( if ( = :list ( :type ( zip/node z ))) ( if ( = level ( :listlevel ( zip/node z ))) ( parse-plain-list lines ( zip/append-child z { :type :listitem :content ( orgmode.inline/parse-inline-elements text )})) ( if ( > level ( :listlevel ( zip/node z ))) ( parse-plain-list lines ( -> z ( zip/down ) ( zip/append-child { :type :list :listlevel level :listtype listtype :content [{ :type :listitem :content ( orgmode.inline/parse-inline-elements text )}]}) ( zip/down ) ( zip/rightmost ))) ( parse-plain-list lines ( enclosing-plain-list z level ) params ))) ( parse-plain-list lines ( -> z ( zip/append-child { :type :list :listlevel level :listtype listtype :content [{ :type :listitem :content ( orgmode.inline/parse-inline-elements text )}]}) ( zip/down ) ( zip/rightmost )))))) ([[ line & rest :as lines ] z ] ( handle-last-line [ line z ] ( let [ indent-re ( re-pattern ( format \"(\\\\s{%d,})(.*)\" ( :listlevel ( zip/node z ))))] ( condp re-matches line plain-list-re :>> ( partial parse-plain-list rest z ) indent-re :>> # ( parse-plain-list rest ( -> z ( zip/down ) ( zip/append-child %1 ) ( zip/up ))) ( next-line lines ( zip/up z )))))))","title":"parse-plain-list"},{"location":"orgmode/block/#append-table-line","text":"Append table row s to location z. Splits s into fields ( append-table-line z s ) (defn) ( defn append-table-line [ z s ] ( let [ row ( if ( re-matches # \"[-+]+\\|?\" s ) :tline ( map s/trim ( s/split s # \"\\|\" )))] ( zip/edit z # ( update-in % [ :rows ] conj row ))))","title":"append-table-line"},{"location":"orgmode/block/#add-table-formula","text":"Add table formula at z, splitting s into separate formulas. ( add-table-formula z s ) (defn) ( defn add-table-formula [ z s ] ( zip/edit z # ( update-in % [ :formulas ] ( s/split s # \"::\" ))))","title":"add-table-formula"},{"location":"orgmode/block/#parse-table","text":"Parse a table to add at location z ( parse-table [ & lines ] z [ _ tblline ]) (defn) ( defn parse-table [[ & lines ] z [ _ tblline ]] ( let [ fields ( map s/trim ( s/split tblline # \"\\|\" )) z ' ( -> z ( zip/append-child { :type :table :content [] :rows [ fields ]}) ( zip/down ) ( zip/rightmost ))] ( loop [ ls lines z '' z ' ] ( handle-last-line [( first ls ) z '' ] ( if-let [[ _ l ] ( re-matches table-re ( first ls ))] ( recur ( rest ls ) ( append-table-line z '' l )) ( if-let [[ _ f ] ( re-matches table-formula-re ( first ls ))] ( next-line ( rest ls ) ( add-table-formula z '' f )) ( next-line ls ( zip/up z '' ))))))))","title":"parse-table"},{"location":"orgmode/block/#add-line-element","text":"Parse line for inline elements and add sequence at z. ( add-line-element lines z line ) (defn) ( defn add-line-element [ lines z line ] # ( next-line lines ( if ( re-matches # \"\\s*\" line ) ( -> z ( zip/append-child { :type :p :content []}) ( zip/down ) ( zip/rightmost )) ( reduce zip/append-child z ( orgmode.inline/parse-inline-elements line )))))","title":"add-line-element"},{"location":"orgmode/block/#next-line_1","text":"( next-line [ line & rest ] z ) (defn) ( defn next-line [[ line & rest ] z ] \"Process each line with the list of block element parsers. Return the root of the created zipper structure\" ( handle-last-line [ line z ] ( condp re-matches line block-open-re :>> ( partial parse-block rest z ) attrib-re :>> ( partial parse-attrib rest z ) headline-re :>> ( partial parse-headline rest z ) prop-open-re :>> ( partial parse-property rest z ) plain-list-re :>> ( partial parse-plain-list rest z ) table-re :>> ( partial parse-table rest z ) footnote-def-re :>> ( partial parse-footnote rest z ) comment-re :>> ( partial parse-comment rest z ) ( add-line-element rest z line ))))","title":"next-line"},{"location":"orgmode/block/#parse-lines","text":"Parse coll as org-mode formatting ( parse-lines coll ) (defn) ( defn parse-lines [ coll ] ( let [ root ( clojure.zip/xml-zip { :level 0 })] ( trampoline next-line coll root )))","title":"parse-lines"},{"location":"orgmode/core-test/","text":"orgmode.core-test \u00b6 (ns) ( ns orgmode.core-test ( :require [ orgmode.core :as orgmode ] [ midje.sweet :refer :all ])) Testing inlines x \u00b6 (def) ( def x ( atom nil )) test-inline-fmt \u00b6 Perform a test on inline elements (defmacro) ( defmacro test-inline-fmt [ string content type ] ` ( with-state-changes [( before :facts ( reset! x ( orgmode/parse-str ~ string )))] ( fact ( get-in @ x [ :content 0 :content 0 ]) => ~ content ) ( fact ( get-in @ x [ :content 0 :type ]) => ~ type ) ( fact ( get-in @ x [ :content 0 :inline ]) => true ))) test-inline \u00b6 Check inline elment parsing (defmacro) ( defmacro test-inline [ string & path-result-pairs ] ( when path-result-pairs ( let [ fs ( for [[ p r ] ( partition 2 path-result-pairs )] ` ( fact ( get-in @ x ~ p ) => ~ r ))] ` ( fact ~ string ( with-state-changes [( before :facts ( reset! x ( orgmode/parse-str ~ string )))] ~@ fs ))))) Formatting \u00b6 Formatting (fact) ( fact \"Formatting\" ( test-inline-fmt \"*Bold text*\" \"Bold text\" :bold ) ( test-inline-fmt \"/Italic text/\" \"Italic text\" :italic ) ( test-inline-fmt \"+Striken text+\" \"Striken text\" :strike-through ) ( test-inline-fmt \"_Underline text_\" \"Underline text\" :underline ) ( test-inline-fmt \"=Verbatim text=\" \"Verbatim text\" :verbatim ) ( test-inline-fmt \"~Code text~\" \"Code text\" :code )) Footnotes \u00b6 Footnotes (fact) ( fact \"Footnotes\" ( test-inline \"Footnote [1]\" [ :content 1 :type ] :footnote-ref [ :content 1 :id ] \"1\" [ :content 1 :inline ] true ) ( test-inline \"Foornote [fn:blue]\" [ :content 1 :type ] :footnote-ref [ :content 1 :id ] \"blue\" [ :content 1 :inline ] true )) Links \u00b6 Links (fact) ( fact \"Links\" ( test-inline \"[[http://bnbeckwith.com]]\" [ :content 0 :uri ] \"http://bnbeckwith.com\" [ :content 0 :type ] :link [ :content 0 :inline ] true [ :content 0 :content 0 ] \"http://bnbeckwith.com\" ) ( test-inline \"[[http://bnbeckwith.com][website]]\" [ :content 0 :uri ] \"http://bnbeckwith.com\" [ :content 0 :type ] :link [ :content 0 :inline ] true [ :content 0 :content 0 ] \"website\" )) Targets \u00b6 Target (fact) ( fact \"Targets\" ( test-inline \"<<target>>\" [ :content 0 :id ] \"target\" [ :content 0 :inline ] true [ :content 0 :type ] :target ) ( test-inline \"<<target two>>\" [ :content 0 :id ] \"target two\" [ :content 0 :inline ] true [ :content 0 :type ] :target )) Active Timestamps \u00b6 Active Timestamp (fact) ( fact \"Active Timestamps\" ( test-inline \"<1900-01-01 Mon>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :active [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] nil [ :content 0 :minute ] nil ) ( test-inline \"<1900-01-01 Mon 12:12>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :active [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" ) ( test-inline \"<1900-01-01 Mon 12:12-1:30>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :active [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" [ :content 0 :end-hour ] \"1\" [ :content 0 :end-minute ] \"30\" )) Inactive Timestamps \u00b6 Inactive Timestamp (fact) ( fact \"Inactive Timestamps\" ( test-inline \"[1900-01-01 Mon]\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :inactive [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] nil [ :content 0 :minute ] nil ) ( test-inline \"[1900-01-01 Mon 12:12]\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :inactive [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" ) ( test-inline \"[1900-01-01 Mon 12:12-1:30]\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :inactive [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" [ :content 0 :end-hour ] \"1\" [ :content 0 :end-minute ] \"30\" )) Timestamp Ranges \u00b6 Range (fact) ( fact \"Timestamp Ranges\" ( test-inline \"<1900-01-01 Mon>--<1901-01-01 Tue>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :range [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] nil [ :content 0 :minute ] nil [ :content 0 :end-year ] \"1901\" [ :content 0 :end-month ] \"01\" [ :content 0 :end-day ] \"01\" [ :content 0 :end-dayname ] \"Tue\" [ :content 0 :end-hour ] nil [ :content 0 :end-minute ] nil ) ( test-inline \"<1900-01-01 Mon 2:55>--<1901-01-01 Tue 6:40>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :range [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"2\" [ :content 0 :minute ] \"55\" [ :content 0 :end-year ] \"1901\" [ :content 0 :end-month ] \"01\" [ :content 0 :end-day ] \"01\" [ :content 0 :end-dayname ] \"Tue\" [ :content 0 :end-hour ] \"6\" [ :content 0 :end-minute ] \"40\" ))","title":"orgmode.core-test"},{"location":"orgmode/core-test/#orgmodecore-test","text":"(ns) ( ns orgmode.core-test ( :require [ orgmode.core :as orgmode ] [ midje.sweet :refer :all ])) Testing inlines","title":"orgmode.core-test"},{"location":"orgmode/core-test/#x","text":"(def) ( def x ( atom nil ))","title":"x"},{"location":"orgmode/core-test/#test-inline-fmt","text":"Perform a test on inline elements (defmacro) ( defmacro test-inline-fmt [ string content type ] ` ( with-state-changes [( before :facts ( reset! x ( orgmode/parse-str ~ string )))] ( fact ( get-in @ x [ :content 0 :content 0 ]) => ~ content ) ( fact ( get-in @ x [ :content 0 :type ]) => ~ type ) ( fact ( get-in @ x [ :content 0 :inline ]) => true )))","title":"test-inline-fmt"},{"location":"orgmode/core-test/#test-inline","text":"Check inline elment parsing (defmacro) ( defmacro test-inline [ string & path-result-pairs ] ( when path-result-pairs ( let [ fs ( for [[ p r ] ( partition 2 path-result-pairs )] ` ( fact ( get-in @ x ~ p ) => ~ r ))] ` ( fact ~ string ( with-state-changes [( before :facts ( reset! x ( orgmode/parse-str ~ string )))] ~@ fs )))))","title":"test-inline"},{"location":"orgmode/core-test/#formatting","text":"Formatting (fact) ( fact \"Formatting\" ( test-inline-fmt \"*Bold text*\" \"Bold text\" :bold ) ( test-inline-fmt \"/Italic text/\" \"Italic text\" :italic ) ( test-inline-fmt \"+Striken text+\" \"Striken text\" :strike-through ) ( test-inline-fmt \"_Underline text_\" \"Underline text\" :underline ) ( test-inline-fmt \"=Verbatim text=\" \"Verbatim text\" :verbatim ) ( test-inline-fmt \"~Code text~\" \"Code text\" :code ))","title":"Formatting"},{"location":"orgmode/core-test/#footnotes","text":"Footnotes (fact) ( fact \"Footnotes\" ( test-inline \"Footnote [1]\" [ :content 1 :type ] :footnote-ref [ :content 1 :id ] \"1\" [ :content 1 :inline ] true ) ( test-inline \"Foornote [fn:blue]\" [ :content 1 :type ] :footnote-ref [ :content 1 :id ] \"blue\" [ :content 1 :inline ] true ))","title":"Footnotes"},{"location":"orgmode/core-test/#links","text":"Links (fact) ( fact \"Links\" ( test-inline \"[[http://bnbeckwith.com]]\" [ :content 0 :uri ] \"http://bnbeckwith.com\" [ :content 0 :type ] :link [ :content 0 :inline ] true [ :content 0 :content 0 ] \"http://bnbeckwith.com\" ) ( test-inline \"[[http://bnbeckwith.com][website]]\" [ :content 0 :uri ] \"http://bnbeckwith.com\" [ :content 0 :type ] :link [ :content 0 :inline ] true [ :content 0 :content 0 ] \"website\" ))","title":"Links"},{"location":"orgmode/core-test/#targets","text":"Target (fact) ( fact \"Targets\" ( test-inline \"<<target>>\" [ :content 0 :id ] \"target\" [ :content 0 :inline ] true [ :content 0 :type ] :target ) ( test-inline \"<<target two>>\" [ :content 0 :id ] \"target two\" [ :content 0 :inline ] true [ :content 0 :type ] :target ))","title":"Targets"},{"location":"orgmode/core-test/#active-timestamps","text":"Active Timestamp (fact) ( fact \"Active Timestamps\" ( test-inline \"<1900-01-01 Mon>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :active [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] nil [ :content 0 :minute ] nil ) ( test-inline \"<1900-01-01 Mon 12:12>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :active [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" ) ( test-inline \"<1900-01-01 Mon 12:12-1:30>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :active [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" [ :content 0 :end-hour ] \"1\" [ :content 0 :end-minute ] \"30\" ))","title":"Active Timestamps"},{"location":"orgmode/core-test/#inactive-timestamps","text":"Inactive Timestamp (fact) ( fact \"Inactive Timestamps\" ( test-inline \"[1900-01-01 Mon]\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :inactive [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] nil [ :content 0 :minute ] nil ) ( test-inline \"[1900-01-01 Mon 12:12]\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :inactive [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" ) ( test-inline \"[1900-01-01 Mon 12:12-1:30]\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :inactive [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"12\" [ :content 0 :minute ] \"12\" [ :content 0 :end-hour ] \"1\" [ :content 0 :end-minute ] \"30\" ))","title":"Inactive Timestamps"},{"location":"orgmode/core-test/#timestamp-ranges","text":"Range (fact) ( fact \"Timestamp Ranges\" ( test-inline \"<1900-01-01 Mon>--<1901-01-01 Tue>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :range [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] nil [ :content 0 :minute ] nil [ :content 0 :end-year ] \"1901\" [ :content 0 :end-month ] \"01\" [ :content 0 :end-day ] \"01\" [ :content 0 :end-dayname ] \"Tue\" [ :content 0 :end-hour ] nil [ :content 0 :end-minute ] nil ) ( test-inline \"<1900-01-01 Mon 2:55>--<1901-01-01 Tue 6:40>\" [ :content 0 :inline ] true [ :content 0 :type ] :timestamp [ :content 0 :timetype ] :range [ :content 0 :year ] \"1900\" [ :content 0 :month ] \"01\" [ :content 0 :day ] \"01\" [ :content 0 :dayname ] \"Mon\" [ :content 0 :hour ] \"2\" [ :content 0 :minute ] \"55\" [ :content 0 :end-year ] \"1901\" [ :content 0 :end-month ] \"01\" [ :content 0 :end-day ] \"01\" [ :content 0 :end-dayname ] \"Tue\" [ :content 0 :end-hour ] \"6\" [ :content 0 :end-minute ] \"40\" ))","title":"Timestamp Ranges"},{"location":"orgmode/core/","text":"Core functionality \u00b6 These are the main parsing functions orgmode.core \u00b6 (ns) ( ns orgmode.core ( :require [ clojure.string :as s ] [ clojure.zip :as zip ] [ clojure.java.io :as io ] [ orgmode.block :as block ] [ orgmode.html :as html ])) Parsing functions \u00b6 These two are the workhorses that will parse an orgmode file, or sequence of lines and produce a tree structures representing the parsed elements. parse-lines \u00b6 Parse coll as a sequence of orgmode lines ( parse-lines coll ) (defn) ( defn parse-lines [ coll ] ( orgmode.block/parse-lines coll )) parse-str \u00b6 Split a string and parse it ( parse-str x ) (defn) ( defn parse-str [ x ] ( parse-lines ( s/split-lines x ))) parse \u00b6 Open x and parse lines ( parse x ) (defn) ( defn parse [ x ] ( with-open [ r ( io/reader x )] ( parse-lines ( line-seq r )))) convert \u00b6 Convert the structure to html The user can supply a function for handling source blocks. Generated formatted text \u00b6 ( convert r ) ( convert r f ) (defn) ( defn convert ([ r ] ( html/org-to-html r )) ([ r f ] ( binding [ orgmode.html/*user-src-fn* f ] ( convert r )))) Utilities \u00b6 The functions aid in the handling of the resulting tree from the parsing functions. zip \u00b6 Returns a zipper from org elements (from orgmode/parse) ( zip root ) (defn) ( defn zip [ root ] ( clojure.zip/xml-zip root )) getall \u00b6 Returns all nodes from root satisifying f ( getall root f ) (defn) ( defn getall [ root f ] ( loop [ acc [] , z root ] ( let [ acc ( if ( f ( zip/node z )) ( conj acc ( zip/node z )) acc )] ( if ( zip/end? z ) acc ( recur acc ( zip/next z ))))))","title":"Core"},{"location":"orgmode/core/#core-functionality","text":"These are the main parsing functions","title":"Core functionality"},{"location":"orgmode/core/#orgmodecore","text":"(ns) ( ns orgmode.core ( :require [ clojure.string :as s ] [ clojure.zip :as zip ] [ clojure.java.io :as io ] [ orgmode.block :as block ] [ orgmode.html :as html ]))","title":"orgmode.core"},{"location":"orgmode/core/#parsing-functions","text":"These two are the workhorses that will parse an orgmode file, or sequence of lines and produce a tree structures representing the parsed elements.","title":"Parsing functions"},{"location":"orgmode/core/#parse-lines","text":"Parse coll as a sequence of orgmode lines ( parse-lines coll ) (defn) ( defn parse-lines [ coll ] ( orgmode.block/parse-lines coll ))","title":"parse-lines"},{"location":"orgmode/core/#parse-str","text":"Split a string and parse it ( parse-str x ) (defn) ( defn parse-str [ x ] ( parse-lines ( s/split-lines x )))","title":"parse-str"},{"location":"orgmode/core/#parse","text":"Open x and parse lines ( parse x ) (defn) ( defn parse [ x ] ( with-open [ r ( io/reader x )] ( parse-lines ( line-seq r ))))","title":"parse"},{"location":"orgmode/core/#convert","text":"Convert the structure to html The user can supply a function for handling source blocks.","title":"convert"},{"location":"orgmode/core/#generated-formatted-text","text":"( convert r ) ( convert r f ) (defn) ( defn convert ([ r ] ( html/org-to-html r )) ([ r f ] ( binding [ orgmode.html/*user-src-fn* f ] ( convert r ))))","title":"Generated formatted text"},{"location":"orgmode/core/#utilities","text":"The functions aid in the handling of the resulting tree from the parsing functions.","title":"Utilities"},{"location":"orgmode/core/#zip","text":"Returns a zipper from org elements (from orgmode/parse) ( zip root ) (defn) ( defn zip [ root ] ( clojure.zip/xml-zip root ))","title":"zip"},{"location":"orgmode/core/#getall","text":"Returns all nodes from root satisifying f ( getall root f ) (defn) ( defn getall [ root f ] ( loop [ acc [] , z root ] ( let [ acc ( if ( f ( zip/node z )) ( conj acc ( zip/node z )) acc )] ( if ( zip/end? z ) acc ( recur acc ( zip/next z ))))))","title":"getall"},{"location":"orgmode/html/","text":"HTML output \u00b6 Functions to facilitate HTML output orgmode.html \u00b6 (ns) ( ns orgmode.html ( :require [ hiccup.core :only [ html ]] [ clojure.walk :as w ] [ clojure.string :as t ]) ( :import [ org.apache.commons.lang3 StringEscapeUtils ])) Helping Items \u00b6 img-suffix-re \u00b6 (def) ( def img-suffix-re # \"(?i)(png|bmp|jpg|jpeg)$\" ) *user-src-fn* \u00b6 User-defined function to use for SRC blocks of code. This function will be called with the SRC block map passed in. (def) ( def ^ :dynamic *user-src-fn* ( fn [ x ] nil )) squish-seq \u00b6 For any consecutive sequences, merge them into one. ( squish-seq s ) (defn) ( defn squish-seq [ s ] ( letfn [( concat-seq ([] []) ([ x y ] ( vec ( if ( seq? y ) ( concat x ( squish-seq y )) ( into x [ y ])))))] ( reduce concat-seq [] s ))) maybe-img \u00b6 ( maybe-img url ) ( maybe-img url alt ) (defn) ( defn maybe-img ([ url ] ( maybe-img url url )) ([ url alt ] ( if ( re-find img-suffix-re url ) [ :figure [ :img { :src url :alt alt }] ( into [ :figcaption ] alt )] ( into [ :a { :href url }] alt )))) elmtype \u00b6 ( elmtype x ) (defn) ( defn elmtype [ x ] ( if ( map? x ) ( if-let [ t ( :type x )] t :root ) ( if ( sequential? x ) :seq :default ))) hiccupify \u00b6 (defmulti) ( defmulti hiccupify elmtype ) ( defmulti blockprocess :block ) hiccup \u00b6 ( hiccup r ) (defn) ( defn hiccup [ r ] ( squish-seq ( hiccupify r ))) org-to-html \u00b6 ( org-to-html r ) (defn) ( defn org-to-html [ r ] ( hiccup.core/html ( hiccupify r ))) blockprocess :src \u00b6 ( blockprocess x ) (defmethod) ( defmethod blockprocess :src [ x ] ( if-let [ c ( and *user-src-fn* ( *user-src-fn* x ))] c [ :pre [ :code ( StringEscapeUtils/escapeHtml4 ( t/join \"\\n\" ( :content x )))]])) blockprocess :default \u00b6 ( blockprocess x ) (defmethod) ( defmethod blockprocess :default [ x ] ( into [( :block x )] ( :content x ))) hiccupify :headline \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :headline [ x ] ( if ( and ( :tags x ) (( :tags x ) \"noexport\" )) \"\" [ :section { :class ( str \"hsec\" ( inc ( :level x )) ( :tags x ))} [( keyword ( str \"h\" ( inc ( :level x )))) ( :text x )] ( hiccupify ( :content x ))])) hiccupify :root \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :root [ x ] ( into [ :section { :id \"root\" } ] ( hiccupify ( :content x )))) hiccupify :list \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :list [ x ] ( into [( :listtype x )] ( hiccupify ( :content x )))) hiccupify :listitem \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :listitem [ x ] ( into [ :li ] ( map hiccupify ( :content x )))) hiccupify :table \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :table [ x ] ( let [ rows ( :rows x ) hdr? ( = ( second rows ) :tline ) tbl [ :table ( when hdr? ( into [ :tr ] ( map ( fn [ x ] [ :th ( hiccupify x )]) ( first rows ))))] rows ( if hdr? ( next ( filter # ( not= :tline % ) rows )) rows )] ( into tbl ( for [ row rows ] ( into [ :tr ] ( map ( fn [ x ] [ :td ( hiccupify x )]) row )))))) hiccupify :block \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :block [ x ] ( blockprocess x )) hiccupify :link \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :link [ x ] ( let [{ :keys [ uri content ]} x ] ( maybe-img uri content ))) hiccupify :footnote-ref \u00b6 TODO -- consider using :cite? ( hiccupify x ) (defmethod) ( defmethod hiccupify :footnote-ref [ x ] [ :a.footnote { :href ( str \"#\" ( :id x ))} ( :id x )]) hiccupify :footnote \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :footnote [ x ] ( into [ :a.footnote-def { :id ( :id x ) :href ( str \"#\" ( :id x ))}] ( hiccupify ( :content x )))) TODO -- figure out timestamps hiccupify :bold \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :bold [ x ] ( into [ :strong ] ( hiccupify ( :content x )))) hiccupify :italic \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :italic [ x ] ( into [ :em ] ( hiccupify ( :content x )))) hiccupify :underline \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :underline [ x ] ( into [ :u ] ( hiccupify ( :content x )))) hiccupify :code \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :code [ x ] ( into [ :code ] ( hiccupify ( :content x )))) hiccupify :comment \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :comment [ x ] ( list \"<!-- \" ( hiccupify ( :content x )) \" -->\" ( when-let [ tgts ( filter # ( = :target ( :type % )) ( :content x ))] ( map hiccupify tgts )))) hiccupify :verbatim \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :verbatim [ x ] ( into [ :verbatim ] ( :content x ))) hiccupify :target \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :target [ x ] [ :a { :id ( :id x ) :href ( str \"#\" ( :id x ))}]) hiccupify :p \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :p [ x ] [ :p ( hiccupify ( :content x ))]) hiccupify :seq \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :seq [ x ] ( map hiccupify x )) hiccupify :default \u00b6 ( hiccupify x ) (defmethod) ( defmethod hiccupify :default [ x ] ( str x \"\\n\" ))","title":"Html"},{"location":"orgmode/html/#html-output","text":"Functions to facilitate HTML output","title":"HTML output"},{"location":"orgmode/html/#orgmodehtml","text":"(ns) ( ns orgmode.html ( :require [ hiccup.core :only [ html ]] [ clojure.walk :as w ] [ clojure.string :as t ]) ( :import [ org.apache.commons.lang3 StringEscapeUtils ]))","title":"orgmode.html"},{"location":"orgmode/html/#helping-items","text":"","title":"Helping Items"},{"location":"orgmode/html/#img-suffix-re","text":"(def) ( def img-suffix-re # \"(?i)(png|bmp|jpg|jpeg)$\" )","title":"img-suffix-re"},{"location":"orgmode/html/#user-src-fn","text":"User-defined function to use for SRC blocks of code. This function will be called with the SRC block map passed in. (def) ( def ^ :dynamic *user-src-fn* ( fn [ x ] nil ))","title":"*user-src-fn*"},{"location":"orgmode/html/#squish-seq","text":"For any consecutive sequences, merge them into one. ( squish-seq s ) (defn) ( defn squish-seq [ s ] ( letfn [( concat-seq ([] []) ([ x y ] ( vec ( if ( seq? y ) ( concat x ( squish-seq y )) ( into x [ y ])))))] ( reduce concat-seq [] s )))","title":"squish-seq"},{"location":"orgmode/html/#maybe-img","text":"( maybe-img url ) ( maybe-img url alt ) (defn) ( defn maybe-img ([ url ] ( maybe-img url url )) ([ url alt ] ( if ( re-find img-suffix-re url ) [ :figure [ :img { :src url :alt alt }] ( into [ :figcaption ] alt )] ( into [ :a { :href url }] alt ))))","title":"maybe-img"},{"location":"orgmode/html/#elmtype","text":"( elmtype x ) (defn) ( defn elmtype [ x ] ( if ( map? x ) ( if-let [ t ( :type x )] t :root ) ( if ( sequential? x ) :seq :default )))","title":"elmtype"},{"location":"orgmode/html/#hiccupify","text":"(defmulti) ( defmulti hiccupify elmtype ) ( defmulti blockprocess :block )","title":"hiccupify"},{"location":"orgmode/html/#hiccup","text":"( hiccup r ) (defn) ( defn hiccup [ r ] ( squish-seq ( hiccupify r )))","title":"hiccup"},{"location":"orgmode/html/#org-to-html","text":"( org-to-html r ) (defn) ( defn org-to-html [ r ] ( hiccup.core/html ( hiccupify r )))","title":"org-to-html"},{"location":"orgmode/html/#blockprocess-src","text":"( blockprocess x ) (defmethod) ( defmethod blockprocess :src [ x ] ( if-let [ c ( and *user-src-fn* ( *user-src-fn* x ))] c [ :pre [ :code ( StringEscapeUtils/escapeHtml4 ( t/join \"\\n\" ( :content x )))]]))","title":"blockprocess :src"},{"location":"orgmode/html/#blockprocess-default","text":"( blockprocess x ) (defmethod) ( defmethod blockprocess :default [ x ] ( into [( :block x )] ( :content x )))","title":"blockprocess :default"},{"location":"orgmode/html/#hiccupify-headline","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :headline [ x ] ( if ( and ( :tags x ) (( :tags x ) \"noexport\" )) \"\" [ :section { :class ( str \"hsec\" ( inc ( :level x )) ( :tags x ))} [( keyword ( str \"h\" ( inc ( :level x )))) ( :text x )] ( hiccupify ( :content x ))]))","title":"hiccupify :headline"},{"location":"orgmode/html/#hiccupify-root","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :root [ x ] ( into [ :section { :id \"root\" } ] ( hiccupify ( :content x ))))","title":"hiccupify :root"},{"location":"orgmode/html/#hiccupify-list","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :list [ x ] ( into [( :listtype x )] ( hiccupify ( :content x ))))","title":"hiccupify :list"},{"location":"orgmode/html/#hiccupify-listitem","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :listitem [ x ] ( into [ :li ] ( map hiccupify ( :content x ))))","title":"hiccupify :listitem"},{"location":"orgmode/html/#hiccupify-table","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :table [ x ] ( let [ rows ( :rows x ) hdr? ( = ( second rows ) :tline ) tbl [ :table ( when hdr? ( into [ :tr ] ( map ( fn [ x ] [ :th ( hiccupify x )]) ( first rows ))))] rows ( if hdr? ( next ( filter # ( not= :tline % ) rows )) rows )] ( into tbl ( for [ row rows ] ( into [ :tr ] ( map ( fn [ x ] [ :td ( hiccupify x )]) row ))))))","title":"hiccupify :table"},{"location":"orgmode/html/#hiccupify-block","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :block [ x ] ( blockprocess x ))","title":"hiccupify :block"},{"location":"orgmode/html/#hiccupify-link","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :link [ x ] ( let [{ :keys [ uri content ]} x ] ( maybe-img uri content )))","title":"hiccupify :link"},{"location":"orgmode/html/#hiccupify-footnote-ref","text":"TODO -- consider using :cite? ( hiccupify x ) (defmethod) ( defmethod hiccupify :footnote-ref [ x ] [ :a.footnote { :href ( str \"#\" ( :id x ))} ( :id x )])","title":"hiccupify :footnote-ref"},{"location":"orgmode/html/#hiccupify-footnote","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :footnote [ x ] ( into [ :a.footnote-def { :id ( :id x ) :href ( str \"#\" ( :id x ))}] ( hiccupify ( :content x )))) TODO -- figure out timestamps","title":"hiccupify :footnote"},{"location":"orgmode/html/#hiccupify-bold","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :bold [ x ] ( into [ :strong ] ( hiccupify ( :content x ))))","title":"hiccupify :bold"},{"location":"orgmode/html/#hiccupify-italic","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :italic [ x ] ( into [ :em ] ( hiccupify ( :content x ))))","title":"hiccupify :italic"},{"location":"orgmode/html/#hiccupify-underline","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :underline [ x ] ( into [ :u ] ( hiccupify ( :content x ))))","title":"hiccupify :underline"},{"location":"orgmode/html/#hiccupify-code","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :code [ x ] ( into [ :code ] ( hiccupify ( :content x ))))","title":"hiccupify :code"},{"location":"orgmode/html/#hiccupify-comment","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :comment [ x ] ( list \"<!-- \" ( hiccupify ( :content x )) \" -->\" ( when-let [ tgts ( filter # ( = :target ( :type % )) ( :content x ))] ( map hiccupify tgts ))))","title":"hiccupify :comment"},{"location":"orgmode/html/#hiccupify-verbatim","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :verbatim [ x ] ( into [ :verbatim ] ( :content x )))","title":"hiccupify :verbatim"},{"location":"orgmode/html/#hiccupify-target","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :target [ x ] [ :a { :id ( :id x ) :href ( str \"#\" ( :id x ))}])","title":"hiccupify :target"},{"location":"orgmode/html/#hiccupify-p","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :p [ x ] [ :p ( hiccupify ( :content x ))])","title":"hiccupify :p"},{"location":"orgmode/html/#hiccupify-seq","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :seq [ x ] ( map hiccupify x ))","title":"hiccupify :seq"},{"location":"orgmode/html/#hiccupify-default","text":"( hiccupify x ) (defmethod) ( defmethod hiccupify :default [ x ] ( str x \"\\n\" ))","title":"hiccupify :default"},{"location":"orgmode/inline-test/","text":"orgmode.inline-test \u00b6 (ns) ( ns orgmode.inline-test ( :require [ orgmode.inline :as sut ] [ midje.sweet :as midje ])) Active TimeStamp Regex Test \u00b6 Active Timestamp (midje/fact) ( midje/fact \"Active TimeStamp Regex Test\" ( ->> \"1900-01-01 Mon 12:12\" ( re-seq sut/ts-base ) first ) => [ \"1900-01-01 Mon 12:12\" \"1900\" \"01\" \"01\" \"Mon\" \"12\" \"12\" \"\" nil nil ] ( ->> \"1900-01-01 Mon 12:00-13:15\" ( re-seq sut/ts-base ) first ) => [ \"1900-01-01 Mon 12:00-13:15\" \"1900\" \"01\" \"01\" \"Mon\" \"12\" \"00\" \"-13:15\" \"13\" \"15\" ] ( ->> \"1900-01-01 Mon 12:00\" ( re-seq sut/ts-base ) sut/ts-active-create first ) => { :day \"01\" , :dayname \"Mon\" , :hour \"12\" , :minute \"00\" , :month \"01\" , :timetype :active , :type :timestamp , :year \"1900\" } ( ->> \"1900-01-01 Mon 12:00-13:15\" ( re-seq sut/ts-base ) sut/ts-active-create first ) => { :day \"01\" , :dayname \"Mon\" , :end-hour \"13\" , :end-minute \"15\" , :hour \"12\" , :minute \"00\" , :month \"01\" , :timetype :active , :type :timestamp , :year \"1900\" })","title":"orgmode.inline-test"},{"location":"orgmode/inline-test/#orgmodeinline-test","text":"(ns) ( ns orgmode.inline-test ( :require [ orgmode.inline :as sut ] [ midje.sweet :as midje ]))","title":"orgmode.inline-test"},{"location":"orgmode/inline-test/#active-timestamp-regex-test","text":"Active Timestamp (midje/fact) ( midje/fact \"Active TimeStamp Regex Test\" ( ->> \"1900-01-01 Mon 12:12\" ( re-seq sut/ts-base ) first ) => [ \"1900-01-01 Mon 12:12\" \"1900\" \"01\" \"01\" \"Mon\" \"12\" \"12\" \"\" nil nil ] ( ->> \"1900-01-01 Mon 12:00-13:15\" ( re-seq sut/ts-base ) first ) => [ \"1900-01-01 Mon 12:00-13:15\" \"1900\" \"01\" \"01\" \"Mon\" \"12\" \"00\" \"-13:15\" \"13\" \"15\" ] ( ->> \"1900-01-01 Mon 12:00\" ( re-seq sut/ts-base ) sut/ts-active-create first ) => { :day \"01\" , :dayname \"Mon\" , :hour \"12\" , :minute \"00\" , :month \"01\" , :timetype :active , :type :timestamp , :year \"1900\" } ( ->> \"1900-01-01 Mon 12:00-13:15\" ( re-seq sut/ts-base ) sut/ts-active-create first ) => { :day \"01\" , :dayname \"Mon\" , :end-hour \"13\" , :end-minute \"15\" , :hour \"12\" , :minute \"00\" , :month \"01\" , :timetype :active , :type :timestamp , :year \"1900\" })","title":"Active TimeStamp Regex Test"},{"location":"orgmode/inline/","text":"Inline Element Formatting \u00b6 Aside from the block elements handled in the core, there are particular elements withing text that have meaning. There are roughly two types of elements: links and formatting. orgmode.inline \u00b6 (ns) ( ns orgmode.inline ( :require [ clojure.string :as s ])) Link Elements \u00b6 link-re \u00b6 (def) ( def link-re # \"\\[\\[([^\\]]+)(?:\\]\\[([^\\]]+))?\\]\\]\" ) link-create \u00b6 Create hyperlink structures from a list of regex matches ( link-create coll ) (defn) ( defn link-create [ coll ] ( for [[ _ link text ] coll ] { :type :link :uri link :content [( or text link )]})) footnote-re \u00b6 (def) ( def footnote-re # \"\\[(\\d+|fn:(.*))\\]\" ) footnote-create \u00b6 Creates footnote structures from a list of regex matches ( footnote-create coll ) (defn) ( defn footnote-create [ coll ] ( for [[ _ ref name ] coll ] { :type :footnote-ref :id ( if ( nil? name ) ref name )})) target-re \u00b6 (def) ( def target-re # \"<<\\s*([^>]*?)\\s*>>\" ) target-create \u00b6 Creates target structures from a list of regex matches ( target-create tgts ) (defn) ( defn target-create [ tgts ] ( for [[ _ lbl ] tgts ] { :type :target :id lbl })) Timestamp Elements \u00b6 ts-base \u00b6 hack to make it work with ranges (def) ( def ts-base # \"(\\d{4})-(\\d{2})-(\\d{2}) (\\w{3})(?: (\\d{1,2}):(\\d{2})(-(\\d{1,2}):(\\d{2})|.*)?)?\" ) ts-active-re \u00b6 (def) ( def ts-active-re ( re-pattern ( str \"<\" ts-base \">\" ))) ts-active-create \u00b6 Creates active timestamps from a list of regex matches ( ts-active-create coll ) (defn) ( defn ts-active-create [ coll ] ( for [[ _ Y M D d h m _ Eh Em ] coll ] ( cond-> { :type :timestamp :timetype :active :year Y :month M :day D :dayname d :hour h :minute m } ( and Eh Em ) ( merge { :end-hour Eh :end-minute Em }) :always or ))) ts-inactive-re \u00b6 (def) ( def ts-inactive-re ( re-pattern ( str \"\\\\[\" ts-base \"\\\\]\" ))) ts-inactive-create \u00b6 Create inactive timestamps from a list of regex matches ( ts-inactive-create coll ) (defn) ( defn ts-inactive-create [ coll ] ( map # ( assoc % :timetype :inactive ) ( ts-active-create coll ))) ts-range-re \u00b6 (def) ( def ts-range-re ( re-pattern ( str ts-active-re \"--\" ts-active-re ))) ts-range-create \u00b6 Create timestamp ranges from a list of regex matches ( ts-range-create coll ) (defn) ( defn ts-range-create [ coll ] ( for [[ _ BY BM BD Bd Bh Bm _ _ _ EY EM ED Ed Eh Em _ _ ] coll ] { :type :timestamp :timetype :range :year BY :month BM :day BD :dayname Bd :hour Bh :minute Bm :end-year EY :end-month EM :end-day ED :end-dayname Ed :end-hour Eh :end-minute Em })) Formatting Elements \u00b6 fmt-create \u00b6 Generic function to create a format element from given type ( fmt-create type ) (defn) ( defn fmt-create [ type ] ( fn [ ts ] ( for [[ _ t ] ts ] { :type type :content [ t ]}))) fmt-re \u00b6 Create a re-pattern to match the given delimiter s ( fmt-re s ) (defn) ( defn fmt-re [ s ] ( re-pattern ( str s # \"(\\S(?:.*?\\S)??)\" s ))) re-interleave \u00b6 Split l with on re, interleave this list with the inline elements constructed from ms using cfn ( re-interleave re l cfn ms ) (defn) ( defn re-interleave [ re l cfn ms ] ( let [ ls ( s/split l re ) els ( vec ( map # ( assoc % :inline true ) ( cfn ms )))] ( if ( empty? ls ) els ( vec ( interleave ls ( conj els { :inline true :type :comment :text \"FIX INTERLEAVING\" })))))) make-elem \u00b6 Try to make any inline elements out of strings in coll using re and cstor to match and construct these elements ( make-elem coll re cstor ) (defn) ( defn make-elem [ coll re cstor ] ( flatten ( for [ elem coll ] ( if ( string? elem ) ( if-let [ ms ( re-seq re elem )] ( re-interleave re elem cstor ms ) elem ) elem )))) parse-inline-elements \u00b6 Takes line and breaks it into inline elements and interleaving text ( parse-inline-elements line ) (defn) ( defn parse-inline-elements [ line ] ( -> [ line ] ( make-elem link-re link-create ) ( make-elem footnote-re footnote-create ) ( make-elem target-re target-create ) ( make-elem ts-range-re ts-range-create ) ( make-elem ts-active-re ts-active-create ) ( make-elem ts-inactive-re ts-inactive-create ) ( make-elem ( fmt-re \"\\\\*\" ) ( fmt-create :bold )) ( make-elem ( fmt-re \"/\" ) ( fmt-create :italic )) ( make-elem ( fmt-re \"\\\\+\" ) ( fmt-create :strike-through )) ( make-elem ( fmt-re \"_\" ) ( fmt-create :underline )) ( make-elem ( fmt-re \"=\" ) ( fmt-create :verbatim )) ( make-elem ( fmt-re \"~\" ) ( fmt-create :code ))))","title":"Inline"},{"location":"orgmode/inline/#inline-element-formatting","text":"Aside from the block elements handled in the core, there are particular elements withing text that have meaning. There are roughly two types of elements: links and formatting.","title":"Inline Element Formatting"},{"location":"orgmode/inline/#orgmodeinline","text":"(ns) ( ns orgmode.inline ( :require [ clojure.string :as s ]))","title":"orgmode.inline"},{"location":"orgmode/inline/#link-elements","text":"","title":"Link Elements"},{"location":"orgmode/inline/#link-re","text":"(def) ( def link-re # \"\\[\\[([^\\]]+)(?:\\]\\[([^\\]]+))?\\]\\]\" )","title":"link-re"},{"location":"orgmode/inline/#link-create","text":"Create hyperlink structures from a list of regex matches ( link-create coll ) (defn) ( defn link-create [ coll ] ( for [[ _ link text ] coll ] { :type :link :uri link :content [( or text link )]}))","title":"link-create"},{"location":"orgmode/inline/#footnote-re","text":"(def) ( def footnote-re # \"\\[(\\d+|fn:(.*))\\]\" )","title":"footnote-re"},{"location":"orgmode/inline/#footnote-create","text":"Creates footnote structures from a list of regex matches ( footnote-create coll ) (defn) ( defn footnote-create [ coll ] ( for [[ _ ref name ] coll ] { :type :footnote-ref :id ( if ( nil? name ) ref name )}))","title":"footnote-create"},{"location":"orgmode/inline/#target-re","text":"(def) ( def target-re # \"<<\\s*([^>]*?)\\s*>>\" )","title":"target-re"},{"location":"orgmode/inline/#target-create","text":"Creates target structures from a list of regex matches ( target-create tgts ) (defn) ( defn target-create [ tgts ] ( for [[ _ lbl ] tgts ] { :type :target :id lbl }))","title":"target-create"},{"location":"orgmode/inline/#timestamp-elements","text":"","title":"Timestamp Elements"},{"location":"orgmode/inline/#ts-base","text":"hack to make it work with ranges (def) ( def ts-base # \"(\\d{4})-(\\d{2})-(\\d{2}) (\\w{3})(?: (\\d{1,2}):(\\d{2})(-(\\d{1,2}):(\\d{2})|.*)?)?\" )","title":"ts-base"},{"location":"orgmode/inline/#ts-active-re","text":"(def) ( def ts-active-re ( re-pattern ( str \"<\" ts-base \">\" )))","title":"ts-active-re"},{"location":"orgmode/inline/#ts-active-create","text":"Creates active timestamps from a list of regex matches ( ts-active-create coll ) (defn) ( defn ts-active-create [ coll ] ( for [[ _ Y M D d h m _ Eh Em ] coll ] ( cond-> { :type :timestamp :timetype :active :year Y :month M :day D :dayname d :hour h :minute m } ( and Eh Em ) ( merge { :end-hour Eh :end-minute Em }) :always or )))","title":"ts-active-create"},{"location":"orgmode/inline/#ts-inactive-re","text":"(def) ( def ts-inactive-re ( re-pattern ( str \"\\\\[\" ts-base \"\\\\]\" )))","title":"ts-inactive-re"},{"location":"orgmode/inline/#ts-inactive-create","text":"Create inactive timestamps from a list of regex matches ( ts-inactive-create coll ) (defn) ( defn ts-inactive-create [ coll ] ( map # ( assoc % :timetype :inactive ) ( ts-active-create coll )))","title":"ts-inactive-create"},{"location":"orgmode/inline/#ts-range-re","text":"(def) ( def ts-range-re ( re-pattern ( str ts-active-re \"--\" ts-active-re )))","title":"ts-range-re"},{"location":"orgmode/inline/#ts-range-create","text":"Create timestamp ranges from a list of regex matches ( ts-range-create coll ) (defn) ( defn ts-range-create [ coll ] ( for [[ _ BY BM BD Bd Bh Bm _ _ _ EY EM ED Ed Eh Em _ _ ] coll ] { :type :timestamp :timetype :range :year BY :month BM :day BD :dayname Bd :hour Bh :minute Bm :end-year EY :end-month EM :end-day ED :end-dayname Ed :end-hour Eh :end-minute Em }))","title":"ts-range-create"},{"location":"orgmode/inline/#formatting-elements","text":"","title":"Formatting Elements"},{"location":"orgmode/inline/#fmt-create","text":"Generic function to create a format element from given type ( fmt-create type ) (defn) ( defn fmt-create [ type ] ( fn [ ts ] ( for [[ _ t ] ts ] { :type type :content [ t ]})))","title":"fmt-create"},{"location":"orgmode/inline/#fmt-re","text":"Create a re-pattern to match the given delimiter s ( fmt-re s ) (defn) ( defn fmt-re [ s ] ( re-pattern ( str s # \"(\\S(?:.*?\\S)??)\" s )))","title":"fmt-re"},{"location":"orgmode/inline/#re-interleave","text":"Split l with on re, interleave this list with the inline elements constructed from ms using cfn ( re-interleave re l cfn ms ) (defn) ( defn re-interleave [ re l cfn ms ] ( let [ ls ( s/split l re ) els ( vec ( map # ( assoc % :inline true ) ( cfn ms )))] ( if ( empty? ls ) els ( vec ( interleave ls ( conj els { :inline true :type :comment :text \"FIX INTERLEAVING\" }))))))","title":"re-interleave"},{"location":"orgmode/inline/#make-elem","text":"Try to make any inline elements out of strings in coll using re and cstor to match and construct these elements ( make-elem coll re cstor ) (defn) ( defn make-elem [ coll re cstor ] ( flatten ( for [ elem coll ] ( if ( string? elem ) ( if-let [ ms ( re-seq re elem )] ( re-interleave re elem cstor ms ) elem ) elem ))))","title":"make-elem"},{"location":"orgmode/inline/#parse-inline-elements","text":"Takes line and breaks it into inline elements and interleaving text ( parse-inline-elements line ) (defn) ( defn parse-inline-elements [ line ] ( -> [ line ] ( make-elem link-re link-create ) ( make-elem footnote-re footnote-create ) ( make-elem target-re target-create ) ( make-elem ts-range-re ts-range-create ) ( make-elem ts-active-re ts-active-create ) ( make-elem ts-inactive-re ts-inactive-create ) ( make-elem ( fmt-re \"\\\\*\" ) ( fmt-create :bold )) ( make-elem ( fmt-re \"/\" ) ( fmt-create :italic )) ( make-elem ( fmt-re \"\\\\+\" ) ( fmt-create :strike-through )) ( make-elem ( fmt-re \"_\" ) ( fmt-create :underline )) ( make-elem ( fmt-re \"=\" ) ( fmt-create :verbatim )) ( make-elem ( fmt-re \"~\" ) ( fmt-create :code ))))","title":"parse-inline-elements"},{"location":"orgmode/util/","text":"orgmode.util \u00b6 (ns) ( ns orgmode.util ( :require [ clojure.zip :as zip ])) fix-link \u00b6 ( fix-link n ) (defn) ( defn fix-link [ n ] ( merge n ( when-let [ ms ( re-matches # \"file:(.*)\\.org\" ( :uri n ))] { :uri ( str ( second ms ) \".html\" )}))) org-to-html-links \u00b6 ( org-to-html-links z ) (defn) ( defn org-to-html-links [ z ] ( if ( zip/end? z ) ( zip/root z ) ( recur ( zip/next ( let [ n ( zip/node z )] ( if ( and ( map? n ) ( = :link ( :type n ))) ( zip/edit z fix-link ) z ))))))","title":"orgmode.util"},{"location":"orgmode/util/#orgmodeutil","text":"(ns) ( ns orgmode.util ( :require [ clojure.zip :as zip ]))","title":"orgmode.util"},{"location":"orgmode/util/#fix-link","text":"( fix-link n ) (defn) ( defn fix-link [ n ] ( merge n ( when-let [ ms ( re-matches # \"file:(.*)\\.org\" ( :uri n ))] { :uri ( str ( second ms ) \".html\" )})))","title":"fix-link"},{"location":"orgmode/util/#org-to-html-links","text":"( org-to-html-links z ) (defn) ( defn org-to-html-links [ z ] ( if ( zip/end? z ) ( zip/root z ) ( recur ( zip/next ( let [ n ( zip/node z )] ( if ( and ( map? n ) ( = :link ( :type n ))) ( zip/edit z fix-link ) z ))))))","title":"org-to-html-links"}]}